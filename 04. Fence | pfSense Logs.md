# Logs Integration pfSense - Syslog and Suricata  
---

## Configure syslog-ng pfSense package
In pfSense UI: 
- Go to **System > Package Manager > Available Packages**.
- Search for syslog-ng and install the package.
- Go to **Services > Syslog-ng > **General**.
- Set Interface Selection: loopback , Default Protocol: UDP, Default Port: 1514 (or choose any other port you want)

## Configure pfSense system logs forwarding
### System Logs (Built-in Syslog)
In pfSense UI:  
- Go to **Status > System Logs > Settings**.  
- Under **Remote Logging**, enable **Send log messages to remote syslog server**.  
- Add remote server: `127.0.0.1:1514` (UDP - The logs will be sent to syslog-ng).  
- Select categories to forward (e.g., Firewall, System, DHCP).  
- Save and Apply.  

## Configure syslog-ng Advanced objects for pfSense systems logs forwarding to vector:
In pfSense UI: 
- Go to **Services > Syslog-ng > Advanced**.  
- Add a destination:
  1. Object Name: d_pfsense_syslog
  2. Object Type: Destination (the port assigned is the port we set that listening in vector.yaml for pfSense syslog)
  3. Object Parameters:
     ```
     { network("YOUR-DEBIAN-IP" transport(udp) port(5514)); };
     ```
- Add a log path:
  1. Object Name: log_pfsense_syslog
  2. Object Type: Log
  3. Object Parameters:
     ```
     { source(_DEFAULT); destination(d_pfsense_syslog); };
     ```  
- Save changes.  


## Configure syslog-ng for Suricata EVE JSON:
**Assuming you have installed Suricata pfSense package and have enabled EVE JSON log and EVE Output Type to FILE in your monitoring Interfaces**
In pfSense UI: 
- Go to **Services > Syslog-ng > Advanced**.  
- Add a source:
  1. Object Name: s_suricata
  2. Object Type: Source
  3. Objject Parameters:
     ```
     {
       wildcard-file(
         base-dir("/var/log/suricata")
         filename-pattern("eve.json")
         recursive(yes)
         program_override(suricata)
         flags(no-parse)
       );
     };
     ```
- Add a destination:
  1. Object Name: d_suricata
  2. Object Type: Destination (the port assigned is the port we set that listening in vector.yaml for pfSense suricata events)
  3. Object Parameters:
     ```
     { network("YOUR-DEBIAN-IP" transport(udp) port(6000) template("$MSG\n")); };
     ```
- Add a log path:
  1. Object Name: log_suricata
  2. Object Type: Log
  3. Object Parameters:
     ```
     { source(s_suricata); destination(d_suricata); };
     ```  
- Save changes.  


## Configure Vector for pfSense Logs
Vector will receive: standard pfSense system logs on 5514 (UDP) and Suricata EVE JSON on 6000 (UDP). No additional installation needed (Vector already installed).

## Create Vector Pipeline
Append or create new sources/transforms/sinks in `/etc/vector/vector.yaml`:  
```
data_dir: /var/lib/vector

sources:
  pfsense_syslog:
    type: syslog
    mode: udp
    address: 0.0.0.0:5514
    max_message_size: 102400
  suricata_eve:
    type: socket
    address: 0.0.0.0:6000
    mode: udp
    decoding:
      codec: bytes
  zeek_logs:
    type: file
    include:
      - /opt/zeek/logs/current/*.log
    read_from: end
  wazuh_alerts:
    type: file
    include:
      - /var/ossec/logs/alerts/alerts.json
    read_from: end
    ignore_checkpoints: false

transforms:
  pfsense_filterlog:
    type: remap
    inputs: ["pfsense_syslog"]
    source: |
      if !exists(.appname) || downcase(string!(.appname)) != "filterlog" { abort }
      msg = string!(.message)
      if !match(msg, r'^\d+,') { abort }
      cols = parse_csv!(msg)
      if length(cols) < 22 { abort }
      rule_s = string!(cols[0])
      subrule_s = string!(cols[1])
      iface = string!(cols[4])
      reason = string!(cols[5])
      action = string!(cols[6])
      direction = string!(cols[7])
      ipver_s = string!(cols[8])
      ttl_s = string!(cols[11])
      proto_id_s = string!(cols[15])
      proto_s = string!(cols[16])
      length_s = string!(cols[17])
      src_ip = string!(cols[18])
      dst_ip = string!(cols[19])
      src_port_s = string!(cols[20])
      dst_port_s = string!(cols[21])
      .pfsense.iface = iface
      .pfsense.reason = reason
      .pfsense.action = action
      .pfsense.direction = direction
      if match(rule_s, r'^\d+$') { .pfsense.rule = to_int!(rule_s) }
      if match(subrule_s, r'^\d+$') { .pfsense.subrule = to_int!(subrule_s) }
      if match(ipver_s, r'^\d+$') { .network.iana_number = to_int!(ipver_s) }
      if match(ttl_s, r'^\d+$') { .pfsense.ttl = to_int!(ttl_s) }
      if match(length_s, r'^\d+$') { .network.bytes = to_int!(length_s) }
      if match(proto_id_s, r'^\d+$') {
        .pfsense.proto_id = to_int!(proto_id_s)
      } else if proto_id_s != "" {
        .pfsense.proto_id_raw = proto_id_s
      }
      if match(src_port_s, r'^\d+$') { .source.port = to_int!(src_port_s) }
      if match(dst_port_s, r'^\d+$') { .destination.port = to_int!(dst_port_s) }
      .source.ip = src_ip
      .destination.ip = dst_ip
      if proto_s != "" { .network.transport = downcase(proto_s) }
      .event.category = ["network"]
      .event.type = ["connection"]
      .observer.product = "pfSense"
      if !exists(.tags) || !is_array(.tags) { .tags = [] }
      .tags = push!(.tags, "source_pfsense")

  suricata_parse:
    type: remap
    inputs: ["suricata_eve"]
    source: |
      message_str = string!(.message)
      structured, parse_err = parse_json(message_str)
      if parse_err != null {
        .parse_error = "Failed to parse Suricata EVE JSON: " + to_string(parse_err)
        .raw_message = message_str
        .suricata = {}
      } else {
        .suricata = structured
      }
      if exists(.suricata.timestamp) {
        ts_str, ts_conv_err = to_string(.suricata.timestamp)
        if ts_conv_err == null && ts_str != null {
          parsed_ts, ts_err = parse_timestamp(ts_str, format: "%+")
          if ts_err == null {
            ."@timestamp" = parsed_ts
          } else {
            .timestamp_parse_error = to_string(ts_err)
            ."@timestamp" = now()
          }
        } else {
          ."@timestamp" = now()
        }
      } else {
        ."@timestamp" = now()
      }
      if exists(.suricata.src_ip) { .source.ip = .suricata.src_ip }
      if exists(.suricata.dest_ip) { .destination.ip = .suricata.dest_ip }
      .source.port = to_int(.suricata.src_port) ?? .source.port
      .destination.port = to_int(.suricata.dest_port) ?? .destination.port
      if exists(.suricata.proto) {
        .network.transport = downcase(to_string!(.suricata.proto))
      }
      kind = "generic"
      if exists(.suricata.event_type) {
        kind = downcase(to_string!(.suricata.event_type))
      }
      .event.kind = kind
      if exists(.suricata.alert) {
        if exists(.suricata.alert.signature_id) { .rule.id = .suricata.alert.signature_id }
        if exists(.suricata.alert.signature) { .rule.name = .suricata.alert.signature }
        if exists(.suricata.alert.severity) { .event.severity = to_int!(.suricata.alert.severity) }
        if exists(.suricata.alert.category) {
          .event.category = array([.suricata.alert.category])
        } else {
          .event.category = ["intrusion_detection"]
        }
      } else {
        .event.category = ["network"]
      }
      if exists(.suricata.http) { .http = .suricata.http }
      if exists(.suricata.dns) { .dns = .suricata.dns }
      if exists(.suricata.tls) { .tls = .suricata.tls }
      if exists(.suricata.flow_id) {
        .network.flow.id = to_string!(.suricata.flow_id)
      }
      .observer.type = "firewall"
      .observer.vendor = "Netgate"
      .observer.product = "pfSense"
      .event.original = message_str
      tags = if is_array(.tags) { .tags } else { [] }
      tags = push!(tags, "suricata")
      .tags = push(tags, "network_security")
      del(.message)

  zeek_parse:
    type: remap
    inputs: ["zeek_logs"]
    source: |
      z = parse_json!(.message)
      .zeek = z
      .@timestamp = from_unix_timestamp(z.ts) ?? now()
      if exists(z.id.orig_h) { .source.ip = z.id.orig_h }
      if exists(z.id.resp_h) { .destination.ip = z.id.resp_h }
      if exists(z.id.orig_p) { .source.port = to_int!(z.id.orig_p) }
      if exists(z.id.resp_p) { .destination.port = to_int!(z.id.resp_p) }
      if exists(z.proto) { .network.transport = downcase!(z.proto) }
      .observer.product = "Zeek"
      .event.category = ["network"]
      if !exists(.tags) || !is_array(.tags) { .tags = [] }
      .tags = push!(.tags, "source_zeek")
      del(.message)

  wazuh_parse:
    type: remap
    inputs: ["wazuh_alerts"]
    source: |
      w = parse_json!(.message)
      .wazuh = w
      if exists(w.timestamp) {
        ."@timestamp" = parse_timestamp!(w.timestamp, "%+")
      } else {
        ."@timestamp" = now()
      }
      if exists(w.agent.name) { .host.name = w.agent.name }
      if exists(w.rule.level) {
        .event.kind = "alert"
        .event.severity = to_int!(w.rule.level)
      }
      .tags = ["source_wazuh"]
      del(.message)

sinks:
  es_pfsense:
    type: elasticsearch
    inputs: [pfsense_filterlog]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "pfsense-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1

  es_suricata:
    type: elasticsearch
    inputs: [suricata_parse]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "suricata-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1

  es_zeek:
    type: elasticsearch
    inputs: [zeek_parse]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "zeek-ecs-%Y.%m.%d"

  es_wazuh_alerts:
    type: elasticsearch
    inputs: [wazuh_parse]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "wazuh-alerts-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1
```

## Restart Vector and Watch for Errors
```
sudo systemctl restart vector
```
```
sudo journalctl -u vector -n 50 --no-pager
```  
Look for successful reception and parsing (no parse errors).

## Check if Indices Exist
```
sudo curl --cacert /etc/kibana/http_ca.crt -u elastic https://localhost:9200/_cat/indices/pfsense-logs-*?v
```
```
sudo curl --cacert /etc/kibana/http_ca.crt -u elastic https://localhost:9200/_cat/indices/pfsense-suricata-*?v
```

## Create Kibana Data Views for pfSense
Access Kibana  
Open your browser and go to https://YOUR_SERVER_IP:5601  
Log in with the elastic user and password  

## Navigate to Stack Management  
Step | Action
|----|--------|
 1 | Click the hamburger menu (☰)
 2 | Go to Management → Stack Management
 3 | Click Kibana → Data Views

## Create pfSense syslog Data View
1. Click "Create data view"  
2. Configure the data view:  

| Field | Value |
|-------|-------|
| Name| pfSense Syslog |
| Index pattern | pfsense-ecs-* |
| Timestamp field | timestamp |


## Create pfSense Suricata Data View  
1. Click "Create data view"  
2. Configure the data view:  

| Field | Value |
|-------|-------|
| Name | pfSense Suricata Alerts |
| Index pattern | suricata-ecs-* |
| Timestamp field | timestamp |

3. Click "Save data view to Kibana"  

## Verify Data
Go to Analytics → Discover  
Select your "pfSense Logs" data view  
You should see system logs appearing in real-time. Filter examples:  
host.hostname : "your_pfsense_host"  
message : "filterlog"  # For firewall logs  

Select your "pfSense Suricata Events" data view  
You should see Suricata EVE events. Filter examples:  
event_type : "alert"  
event_type : "dns"  
community_id : *  
