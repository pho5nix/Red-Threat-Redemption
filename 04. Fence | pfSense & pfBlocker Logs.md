# Logs Integration pfSense - Syslog and pfBlockerNG
---

## Configure syslog-ng pfSense package
In pfSense UI: 
- Go to **System > Package Manager > Available Packages**.
- Search for syslog-ng and install the package.
- Go to **Services > Syslog-ng > **General**.
- Set Interface Selection: loopback , Default Protocol: UDP, Default Port: 1514 (or choose any other port you want)

## Configure pfSense system logs forwarding
### System Logs (Built-in Syslog)
In pfSense UI:  
- Go to **Status > System Logs > Settings**.  
- Under **Remote Logging**, enable **Send log messages to remote syslog server**.  
- Add remote server: `127.0.0.1:1514` (UDP - The logs will be sent to syslog-ng).  
- Select categories to forward (e.g., Firewall, System, DHCP).  
- Save and Apply.  

## Configure syslog-ng Advanced objects for pfSense systems logs forwarding to vector:
In pfSense UI: 
- Go to **Services > Syslog-ng > Advanced**.  
- Add a destination:
  1. Object Name: d_pfsense_syslog
  2. Object Type: Destination (the port assigned is the port we set that listening in vector.yaml for pfSense syslog)
  3. Object Parameters:
     ```
     { network("YOUR-DEBIAN-IP" transport(udp) port(5514)); };
     ```
- Add a log path:
  1. Object Name: log_pfsense_syslog
  2. Object Type: Log
  3. Object Parameters:
     ```
     { source(_DEFAULT); destination(d_pfsense_syslog); };
     ```  
- Save changes.  


## Configure syslog-ng for pfBlockerNG:
**Assuming you have installed pfBlocker pfSense package and enabled Feeds and/or DNSBL**
In pfSense UI: 
- Go to **Services > Syslog-ng > Advanced**.  
- Add a source:
  1. Object Name: s_pfblocker
  2. Object Type: Source
  3. Objject Parameters:
     ```
     {
       file("/var/log/pfblockerng/ip_block.log"
         program_override("pfb_ipbl")
         flags(no-parse));

       file("/var/log/pfblockerng/dnsbl.log"
         program_override("pfb_dnsbl")
         flags(no-parse));
     };
     ```
- Add s_pfblocker source to pfsense_syslog log path:
  1. Object Name: log_pfsense_syslog
  2. Object Type: Log
  3. Object Parameters:
     ```
     { source(_DEFAULT); source(s_pfblocker); destination(d_pfsense_syslog); };
     ```  
- Save changes.  
- Restart syslog-ng service in pfSense
```
service syslog-ng restart

# If error
killall syslog-ng
service syslog-ng start
```

## Configure Vector for pfSense Logs
Vector will receive: standard pfSense system logs on 5514 (UDP) and Suricata EVE JSON on 6000 (UDP). No additional installation needed (Vector already installed).

## Create Vector Pipeline
Append or create new sources/transforms/sinks in `/etc/vector/vector.yaml`:  
```
data_dir: /var/lib/vector

sources:
  pfsense_syslog:
    type: syslog
    mode: udp
    address: 0.0.0.0:5514
    max_message_size: 102400

  wazuh_alerts:
    type: file
    include:
      - /var/ossec/logs/alerts/alerts.json
    read_from: end
    ignore_checkpoints: false

transforms:
  pfsense_filterlog:
    type: remap
    inputs: ["pfsense_syslog"]
    source: |
      if !exists(.appname) || downcase(string!(.appname)) != "filterlog" { abort }
      msg = string!(.message)
      if !match(msg, r'^\d+,') { abort }
      cols = parse_csv!(msg)
      if length(cols) < 22 { abort }
      rule_s = string!(cols[0])
      subrule_s = string!(cols[1])
      iface = string!(cols[4])
      reason = string!(cols[5])
      action = string!(cols[6])
      direction = string!(cols[7])
      ipver_s = string!(cols[8])
      ttl_s = string!(cols[11])
      proto_id_s = string!(cols[15])
      proto_s = string!(cols[16])
      length_s = string!(cols[17])
      src_ip = string!(cols[18])
      dst_ip = string!(cols[19])
      src_port_s = string!(cols[20])
      dst_port_s = string!(cols[21])
      .pfsense.iface = iface
      .pfsense.reason = reason
      .pfsense.action = action
      .pfsense.direction = direction
      if match(rule_s, r'^\d+$') { .pfsense.rule = to_int!(rule_s) }
      if match(subrule_s, r'^\d+$') { .pfsense.subrule = to_int!(subrule_s) }
      if match(ipver_s, r'^\d+$') { .network.iana_number = to_int!(ipver_s) }
      if match(ttl_s, r'^\d+$') { .pfsense.ttl = to_int!(ttl_s) }
      if match(length_s, r'^\d+$') { .network.bytes = to_int!(length_s) }
      if match(proto_id_s, r'^\d+$') {
        .pfsense.proto_id = to_int!(proto_id_s)
      } else if proto_id_s != "" {
        .pfsense.proto_id_raw = proto_id_s
      }
      if match(src_port_s, r'^\d+$') { .source.port = to_int!(src_port_s) }
      if match(dst_port_s, r'^\d+$') { .destination.port = to_int!(dst_port_s) }
      .source.ip = src_ip
      .destination.ip = dst_ip
      if proto_s != "" { .network.transport = downcase(proto_s) }
      .event.category = ["network"]
      .event.type = ["connection"]
      .observer.product = "pfSense"
      if !exists(.tags) || !is_array(.tags) { .tags = [] }
      .tags = push!(.tags, "source_pfsense")

  wazuh_parse:
    type: remap
    inputs: ["wazuh_alerts"]
    source: |
      w = parse_json!(.message)
      .wazuh = w
      if exists(w.timestamp) {
        ."@timestamp" = parse_timestamp!(w.timestamp, "%+")
      } else {
        ."@timestamp" = now()
      }
      if exists(w.agent.name) { .host.name = w.agent.name }
      if exists(w.rule.level) {
        .event.kind = "alert"
        .event.severity = to_int!(w.rule.level)
      }
      .tags = ["source_wazuh"]
      del(.message)

  pfblocker_raw:
    type: remap
    inputs: ["pfsense_syslog"]
    source: |
      if !exists(.appname) { abort }
      app = downcase(string!(.appname))
      if app != "pfb_ipbl" && app != "pfb_dnsbl" { abort }
      .pfblocker.type = if app == "pfb_ipbl" { "ip" } else { "dnsbl" }
      .pfblocker.cols = parse_csv!(string!(.message), delimiter: ",")

  pfblocker_parse:
    type: remap
    inputs: ["pfblocker_raw"]
    source: |
      cols = .pfblocker.cols
      if !is_array(cols) { abort }
      col_len = length!(cols)
      if .pfblocker.type == "ip" && col_len >= 20 {
        .pfblocker.timestamp_raw     = string!(cols[0])
        .pfblocker.unix_timestamp    = to_int!(cols[1])
        .observer.interface.id       = string!(cols[2])
        .pfblocker.group             = string!(cols[3])
        .event.action                = downcase(string!(cols[4]))
        .network.iana_number         = to_int!(cols[5])
        .pfblocker.proto_id          = to_int!(cols[6])
        .network.transport           = downcase(string!(cols[7]))
        .source.ip                   = string!(cols[8])
        .destination.ip              = string!(cols[9])
        .source.port                 = to_int!(cols[10])
        .destination.port            = to_int!(cols[11])
        .network.direction           = downcase(string!(cols[12]))
        .source.geo.country_iso_code = string!(cols[13])
        .pfblocker.alias             = string!(cols[14])
        .pfblocker.evaluated_ip      = string!(cols[15])
        .pfblocker.feed              = string!(cols[16])
        .pfblocker.resolved_hostname = string!(cols[17])
        .pfblocker.client_hostname   = string!(cols[18])
        .event.duplicate             = string!(cols[19])
      }
      .event.kind     = if .pfblocker.type == "ip" { "event" } else { "alert" }
      .event.type     = ["denied"]
      .observer.product = "pfBlockerNG"
      .observer.type  = "firewall"
      .event.dataset  = "pfblockerng." + string!(.pfblocker.type)
      del(.message)
      del(.pfblocker.cols)

sinks:
  es_pfsense:
    type: elasticsearch
    inputs: [pfsense_filterlog]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "pfsense-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1

  es_wazuh_alerts:
    type: elasticsearch
    inputs: [wazuh_parse]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: elastic
      password: ${ELASTIC_PASSWORD}
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "wazuh-alerts-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1

  es_pfblocker:
    type: elasticsearch
    inputs: ["pfblocker_parse"]
    endpoints: ["https://localhost:9200"]
    auth:
      strategy: basic
      user: "${ES_USER}"
      password: "${ES_PASSWORD}"
    tls:
      verify_certificate: true
      verify_hostname: true
      ca_file: /etc/vector/elasticsearch-ca.crt
    bulk:
      index: "pfblocker-ecs-%Y.%m.%d"
    buffer:
      type: disk
      max_size: 5368709120
      when_full: block
    batch:
      max_bytes: 10000000
      timeout_secs: 1
```

## Restart Vector and watch for Errors
```
sudo systemctl restart vector
```
```
sudo journalctl -u vector -n 50 --no-pager
```  
Look for successful reception and parsing.

## Check if Indices Exist
```
sudo curl --cacert /etc/kibana/http_ca.crt -u elastic https://localhost:9200/_cat/indices/
```

## Create Kibana Data Views for pfSense
Access Kibana  
Open your browser and go to https://YOUR_SERVER_IP:5601  
Log in with the elastic user and password  

## Navigate to Stack Management  
Step | Action
|----|--------|
 1 | Click the hamburger menu (☰)
 2 | Go to Management → Stack Management
 3 | Click Kibana → Data Views

## Create pfSense syslog Data View
1. Click "Create data view"  
2. Configure the data view:  

| Field | Value |
|-------|-------|
| Name| pfSense Syslog |
| Index pattern | pfsense-ecs-* |
| Timestamp field | timestamp |


## Create pfSense pfBlocker Data View  
1. Click "Create data view"  
2. Configure the data view:  

| Field | Value |
|-------|-------|
| Name | pfSense pfBlocker Logs |
| Index pattern | pfblocker-ecs-* |
| Timestamp field | timestamp |

3. Click "Save data view to Kibana"  

## Verify Data
- Go to Analytics → Discover.
- Select your "pfSense Syslog" or "pfBlocker Logs" data view.
You should see system logs appearing in real-time.
